
/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

clientsClaim();

// Precache all assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// Cache audio files with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'audio',
  new CacheFirst({
    cacheName: 'audio-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50, // Adjust as needed
        maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days
      }),
    ],
  })
);

// Cache image files with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50, // Adjust as needed
        maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days
      }),
    ],
  })
);

// Cache styles, scripts, and fonts with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'script' || request.destination === 'font',
  new CacheFirst({
    cacheName: 'app-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1000, // Adjust based on your needs
        maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days
      }),
    ],
  })
);

// Fallback to network for navigation requests (HTML pages)
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100, // Adjust as needed
        maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days
      }),
    ],
  })
);

// Allow the web app to trigger skipWaiting via registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Fallback mechanism for audio, image, transcript, and text files when offline
self.addEventListener('fetch', (event) => {
  const { request } = event;

  // Handle offline caching for audio, images, transcripts, and text files
  if (
    request.destination === 'audio' ||
    request.destination === 'image' ||
    request.url.includes('/transcripts/') ||
    request.url.endsWith('.txt')
  ) {
    event.respondWith(
      caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse; // Return cached file if available
        }

        // Try fetching from the network and cache it if successful
        return fetch(request)
          .then((networkResponse) => {
            return caches.open('dynamic-cache').then((cache) => {
              cache.put(request, networkResponse.clone());
              return networkResponse;
            });
          })
          .catch(() => {
            // Offline fallback logic: Customize as needed
            if (request.destination === 'image') {
              return caches.match('/fallback-image.jpg'); // Optional fallback for images
            }
            if (request.destination === 'audio') {
              return caches.match('/fallback-audio.mp3'); // Optional fallback for audio
            }
            if (request.url.includes('/transcripts/') || request.url.endsWith('.txt')) {
              return caches.match('/fallback-transcript.txt'); // Optional fallback for transcripts
            }
            return null; // You can return null or handle it differently if no fallback exists
          });
      })
    );
  }
});
